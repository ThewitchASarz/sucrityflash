# V2 SecurityFlash Integration Guide

## Architecture Overview

```
┌─────────────────────────────────────────────────────────────┐
│                  Pentest-AI-Platform V2                      │
│                  (Orchestration + UI Layer)                  │
│                                                              │
│  ┌──────────────┐     ┌──────────────┐    ┌──────────────┐│
│  │   Frontend   │────▶│   V2 API     │───▶│ Orchestrator ││
│  │  (Next.js)   │     │  (FastAPI)   │    │              ││
│  └──────────────┘     └──────────────┘    └───────┬──────┘│
│                                                     │       │
└─────────────────────────────────────────────────────┼───────┘
                                                      │
                                    HTTP API (JWT Auth)
                                                      │
┌─────────────────────────────────────────────────────┼───────┐
│                    SecurityFlash V1                 │       │
│                 (Execution Authority)               ▼       │
│                                                              │
│  ┌──────────────┐     ┌──────────────┐    ┌──────────────┐│
│  │ Control Plane│────▶│Policy Engine │───▶│Worker Runtime││
│  │  (FastAPI)   │     │              │    │  (Executes)  ││
│  └──────────────┘     └──────────────┘    └──────────────┘│
│                                                              │
│  ┌──────────────┐     ┌──────────────┐    ┌──────────────┐│
│  │   Evidence   │     │  Approvals   │    │ Redis Streams││
│  │   Storage    │     │   Manager    │    │ (Event Bus)  ││
│  └──────────────┘     └──────────────┘    └──────────────┘│
│                                                              │
└──────────────────────────────────────────────────────────────┘
```

## Execution Boundaries

### V2 Responsibilities (Orchestration ONLY)
- ✅ User interface (Next.js frontend)
- ✅ API for UI interactions
- ✅ Submit action specs to V1
- ✅ Monitor run progress
- ✅ Query results/evidence from V1
- ✅ Display findings and reports

### V1 Responsibilities (Execution Authority)
- ✅ Policy enforcement
- ✅ Approval workflows (L2/L3)
- ✅ Tool execution via subprocess
- ✅ Evidence storage (immutable)
- ✅ Audit logging
- ✅ Redis Streams event bus
- ✅ Worker Runtime coordination

### FORBIDDEN in V2
- ❌ Direct tool execution (no subprocess)
- ❌ Bypassing approvals
- ❌ Direct evidence storage
- ❌ Policy logic duplication
- ❌ Approval token generation
- ❌ Tool validation

## SecurityFlash V1 API Endpoints

V2 uses these V1 endpoints:

### Authentication
```
POST /api/v1/auth/login
  → Returns JWT token for API access
```

### Projects
```
POST /api/v1/projects
  → Create new project

GET /api/v1/projects
  → List projects

GET /api/v1/projects/{id}
  → Get project details
```

### Scopes
```
POST /api/v1/scopes
  → Create scope (requires dual signature)

GET /api/v1/scopes/{id}
  → Get scope details
```

### Runs
```
POST /api/v1/runs
  → Start new run

GET /api/v1/runs/{id}
  → Get run status (running/completed/failed)
```

### Action Specs
```
POST /api/v1/action-specs
  → Submit action spec for approval/execution
  → V1 handles policy validation, approvals, execution

GET /api/v1/action-specs/{id}
  → Get action spec status
```

### Approvals
```
GET /api/v1/approvals?run_id={id}
  → List pending approvals

POST /api/v1/approvals/{id}/approve
  → Approve action (requires digital signature)

POST /api/v1/approvals/{id}/reject
  → Reject action
```

### Evidence
```
GET /api/v1/evidence?run_id={id}
  → Query evidence (immutable, stored in V1)

GET /api/v1/evidence/{id}
  → Get specific evidence
```

### Findings
```
GET /api/v1/findings?run_id={id}
  → Get findings generated by V1 agents
```

## Authentication Model

### JWT Tokens
- V1 issues JWT tokens after login
- V2 uses JWT for all API requests
- Token format: `Bearer <jwt_token>`
- Token contains: user_id, role, permissions
- Token expiry: Configurable in V1 (default 24h)

### Example Authentication Flow

```python
from clients.securityflash_client import SecurityFlashClient

# Initialize client with V1 URL and token
client = SecurityFlashClient(
    base_url="http://localhost:8000",  # V1 Control Plane
    api_key="<JWT token from V1 login>"
)

# All requests include Authorization header
response = await client.get_run_status(run_id)
```

## Event Flow

### Action Submission Flow

```
1. V2 UI: User creates action
   ↓
2. V2 API: Validates input
   ↓
3. V2 Orchestrator: Submits to V1 via HTTP
   ↓
4. V1 Policy Engine: Validates against scope/policy
   ↓
5a. L1 Action: Auto-approved → V1 Worker executes immediately
5b. L2/L3 Action: Creates approval request → waits
   ↓
6. V1 Worker Runtime: Executes tool via subprocess
   ↓
7. V1 Evidence Service: Stores evidence (immutable)
   ↓
8. V1 Redis Streams: Publishes worker_events
   ↓
9. V2 Orchestrator: Polls V1 for status updates
   ↓
10. V2 UI: Displays results
```

### Approval Flow (L2/L3 Actions)

```
1. V1 Policy Engine: Creates approval request
   ↓
2. V1 publishes to Redis approval_requested stream
   ↓
3. V2 Orchestrator: Polls V1 for pending approvals
   ↓
4. V2 UI: Shows approval request to user
   ↓
5. User approves with digital signature
   ↓
6. V2 API: Submits approval to V1
   ↓
7. V1 Approval Manager: Validates signature + permissions
   ↓
8. V1 publishes approval_granted to Redis
   ↓
9. V1 Worker Runtime: Executes approved action
   ↓
10. Results flow back to V2 for display
```

## Redis Streams (V1 Only)

V1 uses Redis Streams for event coordination.
V2 does NOT directly consume Redis Streams - it polls V1 HTTP API.

### V1 Redis Streams
- `action_approvals` - Approved actions ready for execution
- `worker_events` - Worker execution results
- `approval_requested` - Actions awaiting approval
- `approval_granted` - Approved actions

### Why V2 Doesn't Use Redis Directly
1. **Single source of truth**: V1 Control Plane is the authority
2. **Simpler V2**: HTTP client is easier than Redis consumer
3. **Decoupling**: V2 doesn't need Redis infrastructure
4. **Future-proof**: V1 can change Redis schema without breaking V2

If real-time updates are needed, V1 can expose WebSocket endpoint.

## Configuration

### Required Environment Variables (V2)

```bash
# SecurityFlash V1 API URL (REQUIRED)
SECURITYFLASH_API_URL=http://localhost:8000

# JWT token from V1 login (REQUIRED)
SECURITYFLASH_API_KEY=<jwt_token>

# V2 Database (for UI state only, NOT execution)
DATABASE_URL=postgresql+asyncpg://user:pass@localhost/pentest_v2

# V2 API Port
PORT=3001
```

### V1 Must Be Running First

V2 cannot operate without V1. Before starting V2:

```bash
# 1. Start V1 Control Plane
cd securityflash
make run-api

# 2. Verify V1 is healthy
curl http://localhost:8000/health

# 3. Start V1 Worker Runtime
make run-worker

# 4. Then start V2
cd pentest-ai-platform
export SECURITYFLASH_API_URL=http://localhost:8000
export SECURITYFLASH_API_KEY=<jwt_from_v1>
npm run dev  # Frontend
python main.py  # Backend API
```

## Failure Modes

### V1 Unavailable
- **Symptom**: V2 client raises connection errors
- **Mitigation**: V2 shows "Execution service unavailable" in UI
- **Recovery**: Wait for V1 to restart, V2 automatically reconnects

### JWT Token Expired
- **Symptom**: V1 returns 401 Unauthorized
- **Mitigation**: V2 redirects to login
- **Recovery**: User re-authenticates with V1

### Action Rejected by Policy
- **Symptom**: V1 returns 403 Forbidden with reason
- **Mitigation**: V2 displays policy violation message
- **Recovery**: User modifies action to comply with policy

### Approval Timeout (L2/L3)
- **Symptom**: V1 marks approval as expired (TTL exceeded)
- **Mitigation**: V2 shows "Approval expired, resubmit"
- **Recovery**: User resubmits action spec

### Worker Execution Failure
- **Symptom**: V1 returns run status "failed" with error
- **Mitigation**: V2 displays execution error from V1
- **Recovery**: User reviews error, fixes action spec, resubmits

## Example Code

### Submit Action from V2

```python
from clients.securityflash_client import get_securityflash_client
from workers.orchestrator import get_orchestrator

# Get clients
client = get_securityflash_client()
orchestrator = get_orchestrator()

# Submit action to V1 for execution
action_spec = await orchestrator.submit_action(
    run_id="run-123",
    method="nmap",
    args={"target": "192.168.1.1", "flags": ["-sV"]},
    risk_level="L2"  # Requires approval in V1
)

# V1 will handle:
# - Policy validation
# - Approval workflow
# - Tool execution
# - Evidence storage

# Monitor progress
status = await orchestrator.monitor_run("run-123")
print(f"Run status: {status['status']}")

# Get results when complete
if status['status'] == 'completed':
    results = await orchestrator.get_results("run-123")
    print(f"Evidence: {len(results['evidence'])} items")
    print(f"Findings: {len(results['findings'])} items")
```

### Query Evidence from V2

```python
# Evidence is stored in V1 (immutable)
# V2 queries via HTTP API
evidence_list = await client.get_evidence(run_id="run-123")

for evidence in evidence_list:
    print(f"Evidence ID: {evidence['id']}")
    print(f"Type: {evidence['evidence_type']}")
    print(f"Content: {evidence['content']}")
    # Evidence cannot be modified or deleted
```

## Security Considerations

### V2 Cannot Bypass V1 Security
- V2 has NO access to V1 database
- V2 has NO access to V1 Redis
- V2 has NO tools installed
- V2 can ONLY call V1 HTTP API with valid JWT

### Evidence Immutability
- Evidence stored in V1 only
- V2 can query but never modify
- DELETE operations always return 403 in V1

### Approval Enforcement
- V2 cannot generate approval tokens
- V2 cannot bypass approval workflow
- All L2/L3 actions require V1 approval

### Audit Trail
- All V2 actions logged in V1 audit log
- V2 API calls tracked with user_id from JWT
- Complete chain of custody in V1

## Testing Integration

### Integration Test Script

```bash
#!/bin/bash
# test_v2_v1_integration.sh

# 1. Start V1
cd securityflash
make run-api &
sleep 5

# 2. Verify V1 health
curl -f http://localhost:8000/health || exit 1

# 3. Start V2 with V1 URL
cd pentest-ai-platform
export SECURITYFLASH_API_URL=http://localhost:8000
export SECURITYFLASH_API_KEY=$(curl -X POST http://localhost:8000/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@test.com","password":"admin"}' \
  | jq -r '.access_token')

python main.py &
sleep 5

# 4. Test V2 → V1 flow
python -c "
import asyncio
from clients.securityflash_client import get_securityflash_client

async def test():
    client = get_securityflash_client()
    health = await client.health_check()
    print(f'V1 Health: {health}')

asyncio.run(test())
"

echo "✅ V2 successfully integrated with V1"
```

## Summary

- **V2 = Orchestration + UI**
- **V1 = Execution Authority**
- **All tool execution happens in V1**
- **V2 uses HTTP API to submit actions and query results**
- **V1 handles policy, approvals, evidence, audit**
- **Clear separation of concerns**
