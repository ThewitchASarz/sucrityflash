# V2 UI Workflows - Pentest AI Platform

## Overview

This document describes the complete UI workflows in the SecurityFlash V2 BFF (Backend-For-Frontend) system. V2 is a **stateless proxy** that forwards all requests to SecurityFlash V1, which is the single source-of-truth.

## Architecture

- **Frontend**: React 19.2.3 + TypeScript (localhost:3000)
- **V2 BFF**: FastAPI stateless proxy (localhost:3001)
- **V1 API**: SecurityFlash system-of-record (localhost:8000)
- **Database**: PostgreSQL (only V1 has database access)

**Critical Constraint**: V2 NEVER touches the database. All data operations flow through V1 API.

## Workflow 1: Create Project

### UI Flow
1. User clicks "+ New Project" button
2. Form displays with fields:
   - Project Name (required)
   - Customer Name (required)
   - Description (optional)
3. User fills form and clicks "Create Project"

### API Flow
```
POST /api/v1/projects
Body: {
  "name": "Dealwyzer Security Assessment",
  "customer_name": "Dealwyzer Inc.",
  "description": "Q1 2025 penetration test"
}
```

### Technical Details
- **Frontend**: `App.tsx:122-142` (`createProject` function)
- **V2 BFF**: `backend/api/projects.py` - proxies to V1
- **V1 API**: Creates project in PostgreSQL, returns project object with UUID
- **Result**: Project appears in projects grid with status "ACTIVE"

## Workflow 2: Define Scope

### UI Flow
1. User clicks on a project to view details
2. Clicks "+ Define Scope" button
3. Form displays with fields:
   - Target Systems (textarea, one URL per line)
   - Excluded Systems (textarea)
   - Forbidden Methods (comma-separated)
4. User fills form and clicks "Create Scope"

### API Flow
```
POST /api/v1/projects/{project_id}/scopes
Body: {
  "scope_type": "web_app",
  "targets": [
    {"type": "domain", "value": "https://dealwyzer.com", "criticality": "HIGH"},
    {"type": "domain", "value": "api.dealwyzer.com", "criticality": "HIGH"}
  ],
  "excluded_targets": [],
  "attack_vectors_allowed": ["reconnaissance", "vulnerability_scanning", "exploitation"],
  "attack_vectors_prohibited": ["social_engineering", "dos"],
  "approved_tools": ["nmap", "burpsuite", "sqlmap", "metasploit"]
}
```

### Technical Details
- **Frontend**: `App.tsx:164-218` (`createScope` function)
- **Transform Logic**: Converts simple URL strings to V1's Target object format
  - Detects type (domain vs ip) by checking for `/` character
  - Sets criticality to "HIGH" for targets, "LOW" for exclusions
- **V2 BFF**: `backend/api/scopes.py` - proxies to V1 at `/api/v1/projects/{project_id}/scopes`
- **V1 API**: Creates scope in PostgreSQL, locks scope for immutability
- **Note**: V1 API doesn't have a "list scopes" endpoint - scopes are loaded individually

## Workflow 3: Start Pentest Run

### UI Flow
1. From project detail view, user sees created scopes
2. Clicks "üöÄ Start Pentest" button on a scope
3. UI creates run and starts execution
4. Redirects to run detail view

### API Flow
```
# Step 1: Create run
POST /api/v1/projects/{project_id}/runs
Body: {"scope_id": "{scope_id}"}

# Step 2: Start execution
POST /api/v1/runs/{run_id}/start
Body: {}
```

### Technical Details
- **Frontend**: `App.tsx:258-289` (`createRun` function)
- **V2 BFF**:
  - `backend/api/runs.py:18-21` - Create run endpoint
  - `backend/api/runs.py:28-31` - Start run endpoint
- **V1 API**:
  - Creates Run record with status "PENDING"
  - Queues job for Celery worker
  - Worker picks up job and changes status to "EXECUTING"
- **Polling**: UI immediately starts polling run status every 5 seconds

## Workflow 4: Monitor Real-Time Agent Activity

### UI Flow
1. Run detail page displays multiple sections:
   - **Run Status Badge**: PENDING ‚Üí EXECUTING ‚Üí COMPLETED
   - **Live Stats**: Real-time proof-of-work metrics
   - **Agent Activity Timeline**: Shows actual agent actions
   - **Findings**: Discovered vulnerabilities

### API Flow (Polling every 5 seconds)
```
# Get run status
GET /api/v1/runs/{run_id}

# Get proof-of-work stats
GET /api/v1/runs/{run_id}/stats
Response: {
  "action_specs_count": 47,
  "pending_approvals_count": 2,
  "evidence_count": 23,
  "findings_count": 8,
  "validated_findings_count": 5,
  "last_activity_at": "2025-12-26T10:30:45Z"
}

# Get agent activity timeline
GET /api/v1/runs/{run_id}/timeline
Response: [
  {
    "timestamp": "2025-12-26T10:25:12Z",
    "agent_type": "ReconAgent",
    "action": "DNS enumeration",
    "details": "Discovered 12 subdomains for dealwyzer.com"
  },
  {
    "timestamp": "2025-12-26T10:27:35Z",
    "agent_type": "ScannerAgent",
    "action": "Port scan",
    "details": "Open ports: 80, 443, 8080"
  }
]

# Get findings
GET /api/v1/findings?run_id={run_id}
Response: [
  {
    "id": "uuid",
    "title": "SQL Injection in login form",
    "severity": "CRITICAL",
    "cvss_score": 9.8,
    "validated": true,
    ...
  }
]
```

### Technical Details
- **Frontend**: `App.tsx:311-352` (`pollRunStatus` function)
- **Polling Logic**: Continues every 5 seconds while status is PENDING or EXECUTING
- **Stats Display**: `App.tsx:640-670` - Shows ActionSpecs, approvals, evidence, findings counts
- **Timeline Display**: `App.tsx:672-727` - Maps agent types to icons:
  - üîç ReconAgent
  - üõ°Ô∏è ScannerAgent
  - ‚ö° ExploitAgent
  - üéØ TriageAgent
  - ‚úÖ ValidatorAgent
- **V2 BFF**: All endpoints in `backend/api/runs.py` proxy to V1
- **V1 Implementation**: Timeline and stats endpoints query activity records from PostgreSQL

## Workflow 5: Generate Report

### UI Flow
1. When run status is "COMPLETED" and findings exist
2. User clicks "üìÑ Generate Report" button
3. UI shows "Generating..." loading state
4. Report downloads as PDF

### API Flow
```
# Step 1: Request report generation
POST /api/v1/reports
Body: {"run_id": "{run_id}"}
Response: {"job_id": "{job_id}", "status": "QUEUED"}

# Step 2: Poll job status (every 10 seconds, up to 5 minutes)
GET /api/v1/jobs/{job_id}
Response: {
  "status": "COMPLETED",
  "result": {"report_id": "{report_id}"}
}

# Step 3: Download report
GET /api/v1/reports/{report_id}
Response: PDF binary data
```

### Technical Details
- **Frontend**: `App.tsx:354-429` (3 functions: `generateReport`, `pollReportJob`, `downloadReport`)
- **Job Polling**: Polls every 10 seconds for up to 30 iterations (5 minutes total)
- **V2 BFF**: `backend/api/reports.py` - proxies to V1
- **V1 API**:
  - Queues report generation job
  - Worker generates PDF from findings, evidence, timeline
  - Stores report in database with binary data
- **Download**: Uses blob response type and creates temporary download link

## Workflow 6: Download Audit Bundle

### UI Flow
1. When run status is "COMPLETED" and findings exist
2. User clicks "üì¶ Download Audit Bundle" button
3. ZIP file downloads containing all artifacts

### API Flow
```
POST /api/v1/audit/bundle
Body: {"run_id": "{run_id}"}
Response: ZIP binary data containing:
  - findings.json
  - evidence/ (screenshots, logs)
  - timeline.json
  - action_specs.json
  - metadata.json
```

### Technical Details
- **Frontend**: `App.tsx:431-458` (`generateAuditBundle` function)
- **V2 BFF**: `backend/api/audit.py` - proxies to V1
- **V1 API**:
  - Queries all run artifacts from PostgreSQL
  - Packages into ZIP archive
  - Returns as binary stream
- **Use Case**: Compliance and audit trail preservation

## Workflow 7: Edit/Delete Project

### Edit Flow
1. User clicks ‚úèÔ∏è Edit button on project
2. Browser prompt shows current name
3. User enters new name
4. Project updates immediately

### Delete Flow
1. User clicks üóëÔ∏è Delete button
2. Browser confirmation dialog appears
3. On confirm, project deletes and UI refreshes

### API Flow
```
# Update
PATCH /api/v1/projects/{project_id}
Body: {"name": "New Project Name"}

# Delete
DELETE /api/v1/projects/{project_id}
```

### Technical Details
- **Frontend**: `App.tsx:220-256` (`deleteProject`, `updateProject` functions)
- **V2 BFF**: `backend/api/projects.py` - proxies to V1
- **V1 API**: Updates or soft-deletes project in PostgreSQL

## API Documentation Access

The UI footer provides links to:
- **V1 API Docs**: http://localhost:8000/docs (FastAPI Swagger UI)
- **V2 BFF Docs**: http://localhost:3001/docs (FastAPI Swagger UI)
- **ReDoc**: http://localhost:8000/redoc (Alternative API documentation)
- **V2 Health Check**: http://localhost:3001/health (BFF health status)

## Error Handling

### Common Errors
1. **404 Not Found**: Endpoint doesn't exist in V1 API
   - Check V1 API docs for correct endpoint structure
   - Scopes must use nested path: `/api/v1/projects/{project_id}/scopes`

2. **405 Method Not Allowed**: HTTP method not supported
   - V1 may not have GET endpoint for certain resources
   - Example: No list scopes endpoint, only create/get by ID

3. **401 Unauthorized**: Missing or invalid auth token
   - Frontend currently uses `demo-token` bypass
   - Production should use JWT authentication

4. **500 Internal Server Error**: V1 API failure
   - Check V1 logs: `docker logs securityflash-api`
   - Check database connection

### Error Display
- Errors appear in red banner at top of UI
- Console logs show detailed error information for debugging
- Loading state prevents duplicate submissions

## State Management

The UI uses React hooks for state:
- `projects`: Array of all projects
- `selectedProject`: Currently viewing project
- `scopes`: Array of scopes for current project
- `runs`: Array of runs for current project
- `selectedRun`: Currently viewing run
- `findings`: Array of findings for current run
- `runStats`: Real-time proof-of-work metrics
- `timeline`: Array of agent activity events

All state updates trigger re-renders to show fresh data.

## Security Considerations

1. **Demo Token**: Current implementation uses hardcoded `demo-token`
   - Replace with proper JWT authentication for production
   - Implement token refresh logic

2. **CORS**: V2 BFF allows localhost:3000 and localhost:3001
   - Update for production domains

3. **Input Validation**:
   - Frontend validates required fields
   - V1 API performs server-side validation with Pydantic

4. **SQL Injection**:
   - V1 uses SQLAlchemy ORM (parameterized queries)
   - No raw SQL in codebase

## Performance Optimization

1. **Polling Intervals**:
   - Run status: Every 5 seconds (during execution)
   - Report generation: Every 10 seconds (up to 5 minutes)

2. **Lazy Loading**:
   - Project details loaded on-demand when clicking project
   - Findings loaded only when viewing run

3. **Caching**:
   - Frontend maintains local state to reduce API calls
   - V1 API could add Redis caching layer (not implemented)

## Future Enhancements

1. **WebSocket Support**: Replace polling with real-time updates
2. **Pagination**: Add pagination for large project/finding lists
3. **Search/Filter**: Add search bar and severity filters
4. **Agent Logs**: Show detailed agent execution logs
5. **Approval Workflow**: UI for approving high-risk actions
6. **Multi-user Support**: User management and role-based access control

## Troubleshooting

### Frontend not loading?
```bash
cd frontend
npm install
PORT=3000 npm start
```

### V2 BFF not responding?
```bash
docker ps  # Check if v2-bff container is running
docker logs v2-bff  # Check logs
```

### V1 API errors?
```bash
docker logs securityflash-api
docker logs securityflash-worker  # Check worker logs
```

### Database issues?
```bash
docker logs postgres
docker exec -it postgres psql -U postgres -d securityflash  # Connect to DB
```

## Summary

The V2 UI provides a complete pentesting workflow:
1. ‚úÖ Create projects with customer information
2. ‚úÖ Define test scopes with target URLs
3. ‚úÖ Start AI-powered pentest runs
4. ‚úÖ Monitor real-time agent activity with proof-of-work stats
5. ‚úÖ View discovered findings with severity ratings
6. ‚úÖ Generate professional PDF reports
7. ‚úÖ Download complete audit bundles for compliance

All workflows are **stateless** - V2 BFF only proxies requests to V1, which is the single source-of-truth.
