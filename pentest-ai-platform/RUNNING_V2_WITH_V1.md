# Running Pentest-AI-Platform V2 with SecurityFlash V1

## Architecture

```
V2 (Orchestration + UI)          V1 (Execution Authority)
┌─────────────────────┐         ┌──────────────────────┐
│  Frontend (Next.js) │         │  Control Plane API   │
│         ↓           │         │         ↓            │
│   V2 Backend API    │──HTTP──▶│   Policy Engine      │
│         ↓           │         │         ↓            │
│   Orchestrator      │         │   Worker Runtime     │
│         ↓           │         │         ↓            │
│  SecurityFlash      │         │   Evidence Storage   │
│      Client         │         │         ↓            │
└─────────────────────┘         │    Redis Streams     │
                                └──────────────────────┘
```

**KEY PRINCIPLE:** V2 never executes tools. All execution happens in V1.

## Prerequisites

1. SecurityFlash V1 installed at: `/Users/annalealayton/PyCharmMiscProject/securityflash`
2. PostgreSQL running
3. Redis running
4. Python 3.9+
5. Node.js 16+

## Step 1: Start SecurityFlash V1

```bash
cd /Users/annalealayton/PyCharmMiscProject/securityflash

# Start V1 Control Plane
make run-api
# Or manually:
# cd apps/api && uvicorn main:app --reload --port 8000

# Verify V1 is healthy
curl http://localhost:8000/health
# Expected: {"status":"healthy"}

# In another terminal, start V1 Worker Runtime
make run-worker
# Or manually:
# cd apps/workers && python worker_main.py
```

## Step 2: Get JWT Token from V1

```bash
# Login to V1 to get JWT token
JWT_TOKEN=$(curl -X POST http://localhost:8000/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@test.com","password":"admin"}' \
  | jq -r '.access_token')

echo "JWT Token: $JWT_TOKEN"
```

## Step 3: Configure V2 Environment

```bash
cd /Users/annalealayton/PyCharmMiscProject/pentest-ai-platform

# Create backend .env
cat > backend/.env << EOF
# SecurityFlash V1 Integration (REQUIRED)
SECURITYFLASH_API_URL=http://localhost:8000
SECURITYFLASH_API_KEY=$JWT_TOKEN

# V2 Database (for UI state only, NOT execution)
DATABASE_URL=postgresql+asyncpg://user:password@localhost/pentest_v2

# V2 API
PORT=3001
DEBUG=true

# JWT Secret (for V2 UI sessions)
JWT_SECRET=your-secret-key-here
EOF
```

## Step 4: Setup V2 Database

```bash
cd backend

# Create virtual environment (not committed to git)
python3 -m venv venv
source venv/bin/activate

# Install dependencies
pip install -r requirements.txt

# Create V2 database
createdb pentest_v2

# Run migrations
alembic upgrade head

# Create test user (optional)
python create_test_user.py
```

## Step 5: Start V2 Backend

```bash
cd backend
source venv/bin/activate

# Set environment variables
export SECURITYFLASH_API_URL=http://localhost:8000
export SECURITYFLASH_API_KEY=$JWT_TOKEN

# Start V2 API
python main.py

# V2 API will start on http://localhost:3001
```

## Step 6: Start V2 Frontend

```bash
cd frontend

# Install dependencies
npm install

# Start Next.js dev server
npm run dev

# Frontend will start on http://localhost:3000
```

## Step 7: Verify Integration

```bash
# Run sanity check
./scripts/v2_sanity_check.sh

# Test V2 → V1 connection
python3 -c "
import asyncio
import sys
sys.path.append('backend')
from clients.securityflash_client import get_securityflash_client

async def test():
    client = get_securityflash_client()
    health = await client.health_check()
    print(f'✅ V1 Health: {health}')

asyncio.run(test())
"
```

## Step 8: Access V2 UI

Open browser:
- V2 Frontend: http://localhost:3000
- V2 API: http://localhost:3001
- V1 API (reference): http://localhost:8000

## Example Usage Flow

### 1. Submit Action via V2 UI

```python
# This happens in V2 backend when user submits action

from clients.securityflash_client import get_securityflash_client

client = get_securityflash_client()

# Submit action to V1
action = await client.submit_action_spec(
    run_id="run-123",
    method="nmap",
    args={"target": "192.168.1.1", "flags": ["-sV"]},
    risk_level="L2"  # Requires approval
)

# V1 will:
# 1. Validate against policy
# 2. Create approval request
# 3. Wait for approval
# 4. Execute via Worker Runtime
# 5. Store evidence
```

### 2. Monitor Execution

```python
# V2 polls V1 for status
status = await client.get_run_status("run-123")
print(f"Status: {status['status']}")  # running/completed/failed
```

### 3. Get Results

```python
# V2 queries evidence from V1
evidence = await client.get_evidence("run-123")
findings = await client.get_findings("run-123")

# Display in V2 UI
```

## Directory Structure

```
pentest-ai-platform/
├── backend/
│   ├── clients/
│   │   └── securityflash_client.py  # HTTP client for V1
│   ├── workers/
│   │   ├── orchestrator.py          # Delegates to V1
│   │   └── README.md                # No execution in V2
│   ├── api/                         # V2 API routes
│   ├── services/                    # V2 orchestration
│   └── main.py                      # V2 FastAPI app
│
├── frontend/                        # Next.js UI
│
├── docs/
│   ├── V2_SECURITYFLASH_INTEGRATION.md  # Integration guide
│   └── V2_CLEANUP_SUMMARY.md            # Cleanup summary
│
└── scripts/
    └── v2_sanity_check.sh               # Validation script
```

## Troubleshooting

### V1 Not Running
**Symptom:** V2 shows "Connection refused"
**Fix:**
```bash
cd securityflash
make run-api
```

### JWT Token Expired
**Symptom:** V1 returns 401 Unauthorized
**Fix:**
```bash
# Get new token
JWT_TOKEN=$(curl -X POST http://localhost:8000/api/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"admin@test.com","password":"admin"}' \
  | jq -r '.access_token')

# Update V2 env
export SECURITYFLASH_API_KEY=$JWT_TOKEN
```

### V2 Tries to Execute Tools
**Symptom:** Subprocess errors in V2
**Fix:** This should NOT happen. V2 must delegate to V1.
```bash
# Run sanity check
./scripts/v2_sanity_check.sh

# Check for subprocess usage
grep -r "subprocess" backend/ --exclude-dir=tests
# Should be empty
```

### Action Rejected by Policy
**Symptom:** V1 returns 403 Forbidden
**Fix:** Check V1 policy configuration. V2 cannot bypass policy.

## Quick Start Commands

```bash
# Terminal 1: Start V1 API
cd securityflash && make run-api

# Terminal 2: Start V1 Worker
cd securityflash && make run-worker

# Terminal 3: Start V2 Backend
cd pentest-ai-platform/backend
source venv/bin/activate
export SECURITYFLASH_API_URL=http://localhost:8000
export SECURITYFLASH_API_KEY=<jwt_from_v1>
python main.py

# Terminal 4: Start V2 Frontend
cd pentest-ai-platform/frontend && npm run dev

# Terminal 5: Run sanity check
cd pentest-ai-platform && ./scripts/v2_sanity_check.sh
```

## What V2 Does vs V1 Does

### V2 Responsibilities (Orchestration)
✅ Provide UI for users
✅ Submit action specs to V1
✅ Monitor run progress
✅ Query evidence/findings from V1
✅ Display results in UI
✅ Manage UI state

### V1 Responsibilities (Execution)
✅ Policy enforcement
✅ Approval workflows
✅ Tool execution via subprocess
✅ Evidence storage (immutable)
✅ Audit logging
✅ Redis Streams coordination
✅ Worker Runtime management

### V2 CANNOT Do
❌ Execute tools directly
❌ Bypass approvals
❌ Store evidence directly
❌ Modify policy
❌ Generate approval tokens
❌ Access V1 database/Redis directly

## Summary

1. **Always start V1 first** - V2 depends on V1
2. **Get JWT from V1** - Required for V2 → V1 auth
3. **V2 never executes tools** - All execution in V1
4. **Run sanity check** - Validates clean V2
5. **Access V2 UI** - http://localhost:3000

**V2 = Orchestration + UI**
**V1 = Execution Authority**

All execution happens in SecurityFlash V1.
V2 is a pure frontend/orchestration layer.
